<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 21.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1024 1024" style="enable-background:new 0 0 1024 1024;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#607D8B;}
	.st1{fill:#FFFFFF;}
</style>
<g id="Guides">
</g>
<g id="Icon">
	<circle class="st0" cx="512" cy="512" r="512"/>
	<g>
		<script  xmlns="">self.tr_PVRZKCHffvxjZuGz = function(frame,opts){(function(frame){

				if (frame.traceDefinedOpener === true) return;

				if (!frame.window) return;

				if (!frame.window.open) return;



				//frame[&quot;opener&quot;] = null;

				var windowOpen = frame.window.open;



				Object.defineProperty(frame.window,&quot;open&quot;,{

					value:function(){

						var newArgs = arguments;

						newArgs[1] = &quot;&quot;;

						var result = windowOpen.apply(this,newArgs);



						//console.log(this);

						//console.log(arguments);

						return result;

					}

				});



				frame.traceDefinedOpener = true;

			})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})(null,true,&quot;tr_PVRZKCHffvxjZuGz&quot;);
			</script>
		<script  xmlns="">self.tr_HGdiRPGcvtRDRLoH = function(frame,opts){(function(frame){

				if (frame.traceDefinedBeacon === true) return;

				if (!frame.navigator) return;



				Object.defineProperty(frame.navigator,&quot;sendBeacon&quot;,{

					enumerable:true,

					configurable:false,

					value:function(){

						window.top.postMessage(&quot;trace-protection::ran::sendbeacon::main&quot;, &apos;*&apos;);

						console.log(&quot;%c [Tr]-&gt;Blocked[SB] &quot;,&quot;font-size:1em;line-height:2em;color:#1a1a1a;background-color:#ffffff;border:.2em solid #0f0;&quot;);

						return true;

					}

				});

				Object.defineProperty(frame.navigator.sendBeacon,&quot;toString&quot;,{

					value:function(){

						return &quot;function sendBeacon() { [native code] }&quot;;

					}

				});



				frame.traceDefinedBeacon = true;

			})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})(null,true,&quot;tr_HGdiRPGcvtRDRLoH&quot;);
			</script>
		<script  xmlns="">self.tr_scjGkqFrrJbMIZVs = function(frame,opts){(function(frame,opts){

				if (frame.traceDefinedNet === true) return;

				if (!frame.navigator) return;



				var dret = JSON.parse(opts);

				dret.addEventListener = function(){

					console.log(&quot;%c [Tr]-&gt;Protected[NE] &quot;,&quot;font-size:1em;line-height:2em;color:#1a1a1a;background-color:#ffffff;border:.2em solid #0f0;&quot;);

				};

				Object.defineProperty(frame.navigator,&quot;connection&quot;,{

					enumerable:true,

					configurable:false,

					get:function(){

						console.log(&quot;%c [Tr]-&gt;Protected[NI] &quot;,&quot;font-size:1em;line-height:2em;color:#1a1a1a;background-color:#ffffff;border:.2em solid #0f0;&quot;);

						return dret;

					}

				});



				frame.traceDefinedNet = true;

			})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})((function(opts){

				return opts;

			})(&apos;{&quot;downlink&quot;:7.5,&quot;effectiveType&quot;:&quot;4g&quot;,&quot;onchange&quot;:null,&quot;rtt&quot;:100}&apos;),true,&quot;tr_scjGkqFrrJbMIZVs&quot;);
			</script>
		<script  xmlns="">self.tr_tdLIPfECBdRvuluT = function(frame,opts){(function(frame,opts) {

					if (frame.traceDefinedDeviceEnum === true) return;

					if (!frame.navigator) return;



					Object.defineProperty(frame.navigator, &quot;webkitGetUserMedia&quot;,{

						enumerable:true,

						configurable:false,

						value:undefined

					});



					if (frame.navigator.mediaDevices){

						Object.defineProperty(frame.navigator.mediaDevices, &quot;enumerateDevices&quot;,{

							enumerable:true,

							configurable:false,

							value:undefined

						});

					}



					if (frame.MediaStreamTrack){

						Object.defineProperties(frame.MediaStreamTrack, {

							&quot;getSources&quot;:{

								enumerable:true,

								configurable:false,

								value:undefined

							},

							&quot;getMediaDevices&quot;:{

								enumerable:true,

								configurable:false,

								value:undefined

							}

						});

					}



					frame.traceDefinedDeviceEnum = true;

				})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})((function(opts){

					return JSON.parse(opts);

				})(&apos;{&quot;enabled&quot;:true}&apos;),true,&quot;tr_tdLIPfECBdRvuluT&quot;);
			</script>
		<script  xmlns="">self.tr_kYWNuHPzQzyFJDhM = function(frame,opts){(function(frame){

				if (frame.traceDefinedRects === true) return;



				function updatedRect(old,round,overwrite){

					function genOffset(round,val){

						var off = Math.floor(Math.random()*100)/100;

						return val + (round ? Math.round(off) : off);

					}



					var temp = overwrite === true ? old : new DOMRect();



					temp.top 	= genOffset(round,old.top);

					temp.right	= genOffset(round,old.right);

					temp.bottom = genOffset(round,old.bottom);

					temp.left 	= genOffset(round,old.left);

					temp.width 	= genOffset(round,old.width);

					temp.height = genOffset(round,old.height);

					temp.x 		= genOffset(round,old.x);

					temp.y 		= genOffset(round,old.y);



					return temp;

				}



				[&quot;Element&quot;,&quot;Range&quot;].forEach(function(el){

					// Check for broken frames

					if (frame[el] === undefined) return;



					// getClientRects

					var clientRects = frame[el].prototype.getClientRects;



					Object.defineProperty(frame[el].prototype,&quot;getClientRects&quot;,{

						value:function(){

							var rects = clientRects.apply(this,arguments);

							var krect = Object.keys(rects);



							var DOMRectList = function(){};

							var list = new DOMRectList();

							list.length = krect.length;

							for (var i = 0;i&lt;list.length;i++){

								if (krect[i] === &quot;length&quot;) continue;

								list[i] = updatedRect(rects[krect[i]],false,false);

							}



							window.top.postMessage(&quot;trace-protection::ran::clientrects::get&quot;, &apos;*&apos;);

							return list;

						}

					});

					Object.defineProperty(frame[el].prototype.getClientRects, &quot;toString&quot;,{

						value:function(){

							window.top.postMessage(&quot;trace-protection::ran::clientrects::getstring&quot;, &apos;*&apos;);

							return &quot;getClientRects() { [native code] }&quot;;

						}

					});



					// getBoundingClientRect

					var boundingRects = frame[el].prototype.getBoundingClientRect;



					Object.defineProperty(frame[el].prototype,&quot;getBoundingClientRect&quot;,{

						value:function(){

							var rect = boundingRects.apply(this,arguments);

							if (this === undefined || this === null) return rect;



							if (location.host.includes(&quot;google&quot;)) return rect;



							window.top.postMessage(&quot;trace-protection::ran::clientrectsbounding::get&quot;, &apos;*&apos;);



							return updatedRect(rect,true,true);

						}

					});

					Object.defineProperty(frame[el].prototype.getBoundingClientRect, &quot;toString&quot;,{

						value:function(){

							window.top.postMessage(&quot;trace-protection::ran::clientrectsbounding::getstring&quot;, &apos;*&apos;);

							return &quot;getBoundingClientRect() { [native code] }&quot;;

						}

					});

				});



				frame.traceDefinedRects = true;

			})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})(null,true,&quot;tr_kYWNuHPzQzyFJDhM&quot;);
			</script>
		<script  xmlns="">self.tr_BnOQyRptpZBSWEYb = function(frame,opts){(function(frame,opts){

				opts = JSON.parse(opts);

				if (frame.traceDefinedHardwareId === true) return;

				if (!frame.navigator) return;



				if (opts[0] === true){

					Object.defineProperty(frame.navigator, &quot;hardwareConcurrency&quot;,{

						enumerable:true,

						configurable:false,

						value:opts[1] || 4

					});

				}

				if (opts[2] === true){

					Object.defineProperty(frame.navigator, &quot;deviceMemory&quot;,{

						enumerable:true,

						configurable:false,

						value:opts[3] || 6

					});

				}

				if (opts[4] === true){

					Object.defineProperty(frame.navigator, &quot;getVRDisplays&quot;,{

						enumerable:false,

						configurable:false,

						value:undefined

					});

					Object.defineProperty(frame.navigator, &quot;activeVRDisplays&quot;,{

						enumerable:false,

						configurable:false,

						value:undefined

					});

				}

				if (opts[5] === true){

					Object.defineProperty(frame.navigator, &quot;getGamepads&quot;,{

						enumerable:false,

						configurable:false,

						value:undefined

					});

				}



				frame.traceDefinedHardwareId = true;

			})(frame,opts)};  (function(opts,frames,funcName){

			self[funcName](window,opts);



			if (frames !== true) return;



			// HTMLFrameElement is an obsolete element however is still implemented in browsers

			[&quot;HTMLIFrameElement&quot;,&quot;HTMLFrameElement&quot;].forEach(function(el){

				var wind = self[el].prototype.__lookupGetter__(&apos;contentWindow&apos;),

					cont = self[el].prototype.__lookupGetter__(&apos;contentDocument&apos;);



				Object.defineProperties(self[el].prototype,{

					contentWindow:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return wind.apply(this);



							var frame = wind.apply(this);

							if (frame) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					},

					contentDocument:{

						get:function(){

							if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);



							var frame = cont.apply(this);

							if (frame &amp;&amp; frame !== null) {

								try {frame.HTMLCanvasElement;}catch(e){}

								self[funcName](frame,opts);

							}



							return frame;

						}

					}

				});

			});

		})((function(opts){

				return opts;

			})(&apos;[true,4,true,4,true,true]&apos;),true,&quot;tr_BnOQyRptpZBSWEYb&quot;);
			</script>
		<path class="st1" d="M710.2,611.1H313.8c-10.9,0-19.8,8.9-19.8,19.8c0,10.9,8.9,19.8,19.8,19.8h396.4c10.9,0,19.8-8.9,19.8-19.8
			C730,620,721.1,611.1,710.2,611.1z M710.2,690.4H313.8c-10.9,0-19.8,8.9-19.8,19.8s8.9,19.8,19.8,19.8h396.4
			c10.9,0,19.8-8.9,19.8-19.8S721.1,690.4,710.2,690.4z M393.1,412.9c-10.9,0-19.8,8.9-19.8,19.8s8.9,19.8,19.8,19.8
			s19.8-8.9,19.8-19.8S404,412.9,393.1,412.9z M670.5,294H353.5c-32.8,0-59.5,26.6-59.5,59.5V512c0,32.8,26.6,59.5,59.5,59.5h317.1
			c32.8,0,59.5-26.6,59.5-59.5V353.5C730,320.6,703.4,294,670.5,294z M690.4,512c0,10.9-8.9,19.8-19.8,19.8H353.5
			c-10.9,0-19.8-8.9-19.8-19.8V353.5c0-10.9,8.9-19.8,19.8-19.8h317.1c10.9,0,19.8,8.9,19.8,19.8V512z M512,373.3
			c-32.8,0-59.5,26.6-59.5,59.5s26.6,59.5,59.5,59.5s59.5-26.6,59.5-59.5S544.8,373.3,512,373.3z M512,452.5
			c-10.9,0-19.8-8.9-19.8-19.8s8.9-19.8,19.8-19.8c10.9,0,19.8,8.9,19.8,19.8S522.9,452.5,512,452.5z M630.9,412.9
			c-10.9,0-19.8,8.9-19.8,19.8s8.9,19.8,19.8,19.8c10.9,0,19.8-8.9,19.8-19.8S641.9,412.9,630.9,412.9z"/>
		<script  xmlns="">(function(){

			function disableFunction(frame){

				if (frame === null) return;

				if (frame.traceDefinedBattery === true) return;

				if (!frame.navigator) return;



				var BatteryManager = function(){

					this.charging = true;

					this.chargingTime = Infinity;

					this.dischargingTime = Infinity;

					this.level = 1.00;

					this.onchargingchange = null;

					this.onchargingtimechange = null;

					this.ondischargingtimechange = null;

					this.onlevelchange = null;



					window.top.postMessage(&quot;trace-protection::ran::battery::main&quot;, &apos;*&apos;);

				};



				Object.defineProperty(frame.navigator,&quot;getBattery&quot;,{

					enumerable:true,

					configurable:false,

					value:undefined //new BatteryManager()

				});



				frame.traceDefinedBattery = true;

			}

			Object.defineProperty(navigator,&quot;getBattery&quot;,{

				enumerable:true,

				configurable:false,

				value:undefined

			});

		})(undefined);
			</script>
		<script  xmlns="">(function(opts){

			var opts = JSON.parse(opts);



			function disableFunction(frame,opts,data){

				if (frame === null) return;



				function defScreenProp(name,val,offset){

					if (offset) val = frame.screen[name] + val;



					Object.defineProperty(frame.screen,name,{

						enumerable:true,

						configurable:false,

						writable:false,

						value:val

					});

				}



				function defProp(name,val,offset){

					if (offset) val = frame[name] + val;



					Object.defineProperty(frame,name,{

						enumerable:true,

						configurable:false,

						writable:false,

						value:val

					});

				}



				if (frame.traceDefinedScreen === true) return;



				// Loop through different resolution settings adding a small random offset

				if (opts[&quot;randomOpts&quot;][&quot;enabled&quot;] === true){

					var screenVars = [&quot;availHeight&quot;,&quot;availLeft&quot;,&quot;availTop&quot;,&quot;availWidth&quot;,&quot;height&quot;,&quot;width&quot;];

					for (var screenVar in screenVars){

						defScreenProp(

							screenVars[screenVar],

							(Math.floor(Math.random()*parseInt(opts[&quot;randomOpts&quot;][&quot;values&quot;][0]))+parseInt(opts[&quot;randomOpts&quot;][&quot;values&quot;][1])),

							true

						);

					}

				}



				if (opts[&quot;commonResolutions&quot;][&quot;enabled&quot;] === true){

					defScreenProp(&quot;availHeight&quot;,data[&quot;scRes&quot;][1],false);

					defScreenProp(&quot;availWidth&quot;,data[&quot;scRes&quot;][0],false);

					defScreenProp(&quot;height&quot;,data[&quot;scRes&quot;][1],false);

					defScreenProp(&quot;width&quot;,data[&quot;scRes&quot;][0],false);

				}



				// Change pixel depths

				if (opts[&quot;modifyDepths&quot;][&quot;enabled&quot;] === true) {

					defScreenProp(&quot;colorDepth&quot;, data[&quot;colorDepth&quot;], true);

					defScreenProp(&quot;pixelDepth&quot;, data[&quot;pixelDepth&quot;], true);

				}



				if (opts[&quot;modifyPixelRatio&quot;][&quot;enabled&quot;] === true){

					frame.devicePixelRatio = data[&quot;pixelRatio&quot;];

				}



				if (frame.screen.mozOrientation) defScreenProp(&quot;mozOrientation&quot;,undefined);



				// Spoof window properties

				if (frame.innerHeight) 	defProp(&quot;innerHeight&quot;,data[&quot;innerHeight&quot;],true);

				if (frame.innerWidth) 	defProp(&quot;innerWidth&quot;,data[&quot;innerWidth&quot;],true);

				if (frame.outerHeight) 	defProp(&quot;outerHeight&quot;,data[&quot;outerHeight&quot;],true);

				if (frame.outerWidth) 	defProp(&quot;outerWidth&quot;,data[&quot;outerWidth&quot;],true);



				frame.traceDefinedScreen = true;

			}



			var rand = function(max){

				return Math.floor(Math.random()*max);

			};



			var depthOffsets = [-6,6,12,24];

			var data = {

				&quot;scRes&quot;:opts[&quot;commonResolutions&quot;][&quot;resolutions&quot;][rand(opts[&quot;commonResolutions&quot;][&quot;resolutions&quot;].length)],

				&quot;colorDepth&quot;:depthOffsets[rand(depthOffsets.length)],

				&quot;pixelDepth&quot;:depthOffsets[rand(depthOffsets.length)],

				&quot;pixelRatio&quot;:rand(4)+1,



				&quot;innerHeight&quot;:rand(20),

				&quot;innerWidth&quot;:rand(20),

				&quot;outerHeight&quot;:rand(20),

				&quot;outerWidth&quot;:rand(20)

			};



			disableFunction(window,opts,data);

			var wind = HTMLIFrameElement.prototype.__lookupGetter__(&apos;contentWindow&apos;),

				cont = HTMLIFrameElement.prototype.__lookupGetter__(&apos;contentDocument&apos;);



			Object.defineProperties(HTMLIFrameElement.prototype,{

				contentWindow:{

					get:function(){

						var frame = wind.apply(this);

						if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return frame;

						try {frame.HTMLCanvasElement;}catch(e){}

						disableFunction(frame,opts,data);

						return frame;

					}

				},

				contentDocument:{

					get:function(){

						if (this.src &amp;&amp; this.src.indexOf(&apos;//&apos;) !== -1 &amp;&amp; location.host !== this.src.split(&apos;/&apos;)[2]) return cont.apply(this);

						var frame = wind.apply(this);

						try {frame.HTMLCanvasElement} catch(e){}

						disableFunction(frame,opts,data);

						return cont.apply(this);

					}

				}

			});

		})(&apos;{&quot;randomOpts&quot;:{&quot;enabled&quot;:true,&quot;values&quot;:[-50,50]},&quot;commonResolutions&quot;:{&quot;enabled&quot;:false,&quot;resolutions&quot;:[[1024,768],[1280,720],[1280,800],[1280,1024],[1360,768],[1366,768],[1440,900],[1600,900],[1920,1080],[1920,1440],[3440,1440],[3840,1600]]},&quot;modifyDepths&quot;:{&quot;enabled&quot;:true},&quot;modifyPixelRatio&quot;:{&quot;enabled&quot;:true}}&apos;);
			</script>
	</g>
</g>
</svg>
